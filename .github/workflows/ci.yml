name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, develop ]

env:
  GO_VERSION: '1.21'
  BINARY_NAME: vault

jobs:
  # Code quality and security checks
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        go-version: '1.21'
        cache: true

    - name: Check Go environment
      run: |
        echo "GOROOT: $GOROOT"
        echo "GOPATH: $GOPATH"
        echo "GO111MODULE: ${GO111MODULE:-"auto"}"
        go version
        go env

    - name: Check formatting
      run: |
        echo "Checking Go files formatting..."
        find . -name '*.go' -not -path '*/vendor/*' -exec gofmt -s -l {} \;
        if [ "$(find . -name '*.go' -not -path '*/vendor/*' -exec gofmt -s -l {} \; | wc -l)" -gt 0 ]; then
          echo "::error::Code is not formatted. Run 'make fmt' to fix."
          exit 1
        fi

    - name: Lint
      run: |
        echo "Running golangci-lint..."
        golangci-lint run --timeout=5m ./...

    - name: Install gosec
      run: |
        echo "Installing gosec..."
        go install github.com/securego/gosec/v2/cmd/gosec@latest
        echo "GOPATH: $GOPATH"
        echo "GOPATH/bin: $GOPATH/bin"
        echo "PATH: $PATH"
        ls -la $GOPATH/bin
        which gosec || echo "gosec not found in PATH"

    - name: Security scan
      run: |
        echo "Current directory: $(pwd)"
        echo "Files in root directory:"
        ls -la
        echo "Go files in project:"
        find . -name '*.go' | head -5
        echo "Total Go files: $(find . -name '*.go' | wc -l)"
        
        echo "\nRunning gosec with full path..."
        export PATH=$PATH:$(go env GOPATH)/bin
        $GOPATH/bin/gosec -version || echo "Failed to get gosec version"
        
        echo "\nRunning gosec scan..."
        $GOPATH/bin/gosec -v -fmt sarif -out ./gosec.sarif ./... || echo "gosec completed with findings"
        
        echo "\nChecking if SARIF file was created..."
        if [ -f "./gosec.sarif" ]; then
          echo "SARIF file created successfully"
          ls -la ./gosec.sarif
        else
          echo "ERROR: gosec.sarif was not created"
          exit 1
        fi

    - name: Upload security scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: gosec.sarif

  # Unit and integration tests
  test:
    name: Tests
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        go-version: ['1.21', '1.22']
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ matrix.go-version }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-${{ matrix.go-version }}-

    - name: Install dependencies
      run: go mod download

    - name: Run unit tests
      run: go test -v -race -short -coverprofile=coverage.out ./...

    - name: Run integration tests
      run: go test -v -race -tags=integration ./tests/...

    - name: Generate coverage report
      run: go tool cover -func=coverage.out

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-${{ matrix.os }}-go${{ matrix.go-version }}

  # Security-focused testing
  security-tests:
    name: Security Tests
    runs-on: ubuntu-latest
    needs: [quality]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-security-${{ hashFiles('**/go.sum') }}

    - name: Install dependencies
      run: go mod download

    - name: Run security tests
      run: |
        go test -v -race -timeout=30m ./tests/security_tests.go
        go test -v -race -timeout=10m ./tests/fuzz_tests.go

    - name: Run acceptance tests
      run: go test -v -race -timeout=15m ./tests/acceptance_tests.go

    - name: Vulnerability scan
      run: |
        go install golang.org/x/vuln/cmd/govulncheck@latest
        govulncheck ./...

  # Performance benchmarks
  benchmarks:
    name: Performance Benchmarks
    runs-on: ubuntu-latest
    needs: [test]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Run benchmarks
      run: |
        go test -bench=. -benchmem -count=3 ./internal/vault/ > benchmark.txt
        cat benchmark.txt

    - name: Upload benchmark results
      uses: actions/upload-artifact@v4
      with:
        name: benchmark-results
        path: benchmark.txt

  # Cross-platform builds
  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [quality, test]
    strategy:
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]
        exclude:
          - goos: windows
            goarch: arm64

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-build-${{ hashFiles('**/go.sum') }}

    - name: Install dependencies
      run: go mod download

    - name: Build binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
      run: |
        VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
        COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        BUILD_TIME=$(date -u '+%Y-%m-%d_%H:%M:%S')
        
        LDFLAGS="-ldflags=-X main.version=${VERSION} -X main.commit=${COMMIT} -X main.buildTime=${BUILD_TIME} -s -w"
        
        BINARY_NAME="${{ env.BINARY_NAME }}-${{ matrix.goos }}-${{ matrix.goarch }}"
        if [ "${{ matrix.goos }}" = "windows" ]; then
          BINARY_NAME="${BINARY_NAME}.exe"
        fi
        
        go build ${LDFLAGS} -o ${BINARY_NAME} ./cmd/vault

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: binaries-${{ matrix.goos }}-${{ matrix.goarch }}
        path: ${{ env.BINARY_NAME }}-*

  # Release creation (temporarily disabled)
  # release:
  #   name: Create Release
  #   runs-on: ubuntu-latest
  #   needs: [security-tests, benchmarks, build]
  #   if: startsWith(github.ref, 'refs/tags/v')
  #   
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4
  #     with:
  #       fetch-depth: 0
  
  #   - name: Download all artifacts
  #     uses: actions/download-artifact@v3
  
  #   - name: Create release archives
  #     run: |
  #       mkdir -p release
  #       
  #       for dir in binaries-*; do
  #         if [ -d "$dir" ]; then
  #           platform=$(echo $dir | sed 's/binaries-//')
  #           cd "$dir"
  #           
  #           for binary in *; do
  #             if [ -f "$binary" ]; then
  #               # Create archive with binary and documentation
  #               tar -czf "../release/${binary%.exe}-${GITHUB_REF#refs/tags/}.tar.gz" \
  #                 "$binary" \
  #                 -C "../" README.md LICENSE SECURITY.md
  #             fi
  #           done
  #           cd ..
  #         fi
  #       done
  
  #   - name: Generate release notes
  #     run: |
  #       echo "# Release Notes" > RELEASE_NOTES.md
  #       echo "" >> RELEASE_NOTES.md
  #       echo "## Changes" >> RELEASE_NOTES.md
  #       git log --pretty=format:"- %s" $(git describe --tags --abbrev=0 HEAD^)..HEAD >> RELEASE_NOTES.md
  #       echo "" >> RELEASE_NOTES.md
  #       echo "## Security" >> RELEASE_NOTES.md
  #       echo "This release has been security tested and validated." >> RELEASE_NOTES.md
  #       echo "" >> RELEASE_NOTES.md
  #       echo "## Checksums" >> RELEASE_NOTES.md
  #       cd release
  #       sha256sum *.tar.gz >> ../RELEASE_NOTES.md
  
  #   - name: Create GitHub release
  #     uses: softprops/action-gh-release@v1
  #     with:
  #       files: release/*.tar.gz
  #       body_path: RELEASE_NOTES.md
  #       draft: false
  #       prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') }}
  #     env:
  #       GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Docker image build and push (temporarily disabled)
  # docker:
  #   name: Docker Build
  #   runs-on: ubuntu-latest
  #   needs: [build]
  #   if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
  #   
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4
  
  #   - name: Set up Docker Buildx
  #     uses: docker/setup-buildx-action@v3
  
  #   - name: Login to Docker Hub
  #     uses: docker/login-action@v3
  #     with:
  #       username: ${{ secrets.DOCKER_USERNAME }}
  #       password: ${{ secrets.DOCKER_PASSWORD }}
  
  #   - name: Extract metadata
  #     id: meta
  #     uses: docker/metadata-action@v5
  #     with:
  #       images: vaultcli/vault
  #       tags: |
  #         type=ref,event=branch
  #         type=ref,event=pr
  #         type=semver,pattern={{version}}
  #         type=semver,pattern={{major}}.{{minor}}
  #         type=semver,pattern={{major}}
  
  #   - name: Build and push Docker image
  #     uses: docker/build-push-action@v5
  #     with:
  #       context: .
  #       platforms: linux/amd64,linux/arm64
  #       push: true
  #       tags: ${{ steps.meta.outputs.tags }}
  #       labels: ${{ steps.meta.outputs.labels }}
  #       cache-from: type=gha
  #       cache-to: type=gha,mode=max

  # Deployment to staging (temporarily disabled)
  # deploy-staging:
  #   name: Deploy to Staging
  #   runs-on: ubuntu-latest
  #   needs: [docker]
  #   if: github.ref == 'refs/heads/main'
  #   environment: staging
  #   
  #   steps:
  #   - name: Deploy to staging
  #     run: |
  #       echo "Deploying to staging environment..."
  #       # Add actual deployment steps here

  # Security notification
  security-notify:
    name: Security Notification
    runs-on: ubuntu-latest
    needs: [security-tests]
    if: failure()
    
    steps:
    - name: Notify security team
      run: |
        echo "Security tests failed - notification would be sent to security team"
        # Add actual notification logic here

  # Performance regression detection
  performance-check:
    name: Performance Regression Check
    runs-on: ubuntu-latest
    needs: [benchmarks]
    
    steps:
    - name: Download benchmark results
      uses: actions/download-artifact@v3
      with:
        name: benchmark-results

    - name: Check for performance regressions
      run: |
        echo "Checking for performance regressions..."
        # Add logic to compare with baseline performance
        cat benchmark.txt